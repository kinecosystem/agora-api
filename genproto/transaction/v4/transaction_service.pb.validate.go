// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: transaction/v4/transaction_service.proto

package transaction

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/golang/protobuf/ptypes"

	common "github.com/kinecosystem/agora-api/genproto/common/v4"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = ptypes.DynamicAny{}

	_ = common.Commitment(0)

	_ = common.Commitment(0)
)

// define the regex for a UUID once up-front
var _transaction_service_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on GetServiceConfigRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetServiceConfigRequest) Validate() error {
	if m == nil {
		return nil
	}

	return nil
}

// GetServiceConfigRequestValidationError is the validation error returned by
// GetServiceConfigRequest.Validate if the designated constraints aren't met.
type GetServiceConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceConfigRequestValidationError) ErrorName() string {
	return "GetServiceConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceConfigRequestValidationError{}

// Validate checks the field values on GetServiceConfigResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetServiceConfigResponse) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetSubsidizerAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfigResponseValidationError{
				field:  "SubsidizerAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetTokenProgram() == nil {
		return GetServiceConfigResponseValidationError{
			field:  "TokenProgram",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetTokenProgram()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfigResponseValidationError{
				field:  "TokenProgram",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetToken() == nil {
		return GetServiceConfigResponseValidationError{
			field:  "Token",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetServiceConfigResponseValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// GetServiceConfigResponseValidationError is the validation error returned by
// GetServiceConfigResponse.Validate if the designated constraints aren't met.
type GetServiceConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetServiceConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetServiceConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetServiceConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetServiceConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetServiceConfigResponseValidationError) ErrorName() string {
	return "GetServiceConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetServiceConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetServiceConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetServiceConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetServiceConfigResponseValidationError{}

// Validate checks the field values on GetMinimumKinVersionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetMinimumKinVersionRequest) Validate() error {
	if m == nil {
		return nil
	}

	return nil
}

// GetMinimumKinVersionRequestValidationError is the validation error returned
// by GetMinimumKinVersionRequest.Validate if the designated constraints
// aren't met.
type GetMinimumKinVersionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMinimumKinVersionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMinimumKinVersionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMinimumKinVersionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMinimumKinVersionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMinimumKinVersionRequestValidationError) ErrorName() string {
	return "GetMinimumKinVersionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMinimumKinVersionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMinimumKinVersionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMinimumKinVersionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMinimumKinVersionRequestValidationError{}

// Validate checks the field values on GetMinimumKinVersionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetMinimumKinVersionResponse) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Version

	return nil
}

// GetMinimumKinVersionResponseValidationError is the validation error returned
// by GetMinimumKinVersionResponse.Validate if the designated constraints
// aren't met.
type GetMinimumKinVersionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMinimumKinVersionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMinimumKinVersionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMinimumKinVersionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMinimumKinVersionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMinimumKinVersionResponseValidationError) ErrorName() string {
	return "GetMinimumKinVersionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMinimumKinVersionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMinimumKinVersionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMinimumKinVersionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMinimumKinVersionResponseValidationError{}

// Validate checks the field values on GetRecentBlockhashRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetRecentBlockhashRequest) Validate() error {
	if m == nil {
		return nil
	}

	return nil
}

// GetRecentBlockhashRequestValidationError is the validation error returned by
// GetRecentBlockhashRequest.Validate if the designated constraints aren't met.
type GetRecentBlockhashRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRecentBlockhashRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRecentBlockhashRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRecentBlockhashRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRecentBlockhashRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRecentBlockhashRequestValidationError) ErrorName() string {
	return "GetRecentBlockhashRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetRecentBlockhashRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRecentBlockhashRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRecentBlockhashRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRecentBlockhashRequestValidationError{}

// Validate checks the field values on GetRecentBlockhashResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetRecentBlockhashResponse) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetBlockhash() == nil {
		return GetRecentBlockhashResponseValidationError{
			field:  "Blockhash",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetBlockhash()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRecentBlockhashResponseValidationError{
				field:  "Blockhash",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// GetRecentBlockhashResponseValidationError is the validation error returned
// by GetRecentBlockhashResponse.Validate if the designated constraints aren't met.
type GetRecentBlockhashResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRecentBlockhashResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRecentBlockhashResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRecentBlockhashResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRecentBlockhashResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRecentBlockhashResponseValidationError) ErrorName() string {
	return "GetRecentBlockhashResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetRecentBlockhashResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRecentBlockhashResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRecentBlockhashResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRecentBlockhashResponseValidationError{}

// Validate checks the field values on GetMinimumBalanceForRentExemptionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned.
func (m *GetMinimumBalanceForRentExemptionRequest) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Size

	return nil
}

// GetMinimumBalanceForRentExemptionRequestValidationError is the validation
// error returned by GetMinimumBalanceForRentExemptionRequest.Validate if the
// designated constraints aren't met.
type GetMinimumBalanceForRentExemptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMinimumBalanceForRentExemptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMinimumBalanceForRentExemptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMinimumBalanceForRentExemptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMinimumBalanceForRentExemptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMinimumBalanceForRentExemptionRequestValidationError) ErrorName() string {
	return "GetMinimumBalanceForRentExemptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMinimumBalanceForRentExemptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMinimumBalanceForRentExemptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMinimumBalanceForRentExemptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMinimumBalanceForRentExemptionRequestValidationError{}

// Validate checks the field values on
// GetMinimumBalanceForRentExemptionResponse with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *GetMinimumBalanceForRentExemptionResponse) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Lamports

	return nil
}

// GetMinimumBalanceForRentExemptionResponseValidationError is the validation
// error returned by GetMinimumBalanceForRentExemptionResponse.Validate if the
// designated constraints aren't met.
type GetMinimumBalanceForRentExemptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMinimumBalanceForRentExemptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMinimumBalanceForRentExemptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMinimumBalanceForRentExemptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMinimumBalanceForRentExemptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMinimumBalanceForRentExemptionResponseValidationError) ErrorName() string {
	return "GetMinimumBalanceForRentExemptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMinimumBalanceForRentExemptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMinimumBalanceForRentExemptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMinimumBalanceForRentExemptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMinimumBalanceForRentExemptionResponseValidationError{}

// Validate checks the field values on GetHistoryRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *GetHistoryRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetAccountId() == nil {
		return GetHistoryRequestValidationError{
			field:  "AccountId",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetAccountId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetHistoryRequestValidationError{
				field:  "AccountId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetHistoryRequestValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Direction

	return nil
}

// GetHistoryRequestValidationError is the validation error returned by
// GetHistoryRequest.Validate if the designated constraints aren't met.
type GetHistoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHistoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHistoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHistoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHistoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHistoryRequestValidationError) ErrorName() string {
	return "GetHistoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetHistoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHistoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHistoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHistoryRequestValidationError{}

// Validate checks the field values on GetHistoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetHistoryResponse) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Result

	if len(m.GetItems()) > 128 {
		return GetHistoryResponseValidationError{
			field:  "Items",
			reason: "value must contain no more than 128 item(s)",
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetHistoryResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// GetHistoryResponseValidationError is the validation error returned by
// GetHistoryResponse.Validate if the designated constraints aren't met.
type GetHistoryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHistoryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHistoryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHistoryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHistoryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHistoryResponseValidationError) ErrorName() string {
	return "GetHistoryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetHistoryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHistoryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHistoryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHistoryResponseValidationError{}

// Validate checks the field values on SignTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *SignTransactionRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetTransaction() == nil {
		return SignTransactionRequestValidationError{
			field:  "Transaction",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignTransactionRequestValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetInvoiceList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignTransactionRequestValidationError{
				field:  "InvoiceList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// SignTransactionRequestValidationError is the validation error returned by
// SignTransactionRequest.Validate if the designated constraints aren't met.
type SignTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignTransactionRequestValidationError) ErrorName() string {
	return "SignTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SignTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignTransactionRequestValidationError{}

// Validate checks the field values on SignTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *SignTransactionResponse) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Result

	if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignTransactionResponseValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInvoiceErrors() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignTransactionResponseValidationError{
					field:  fmt.Sprintf("InvoiceErrors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// SignTransactionResponseValidationError is the validation error returned by
// SignTransactionResponse.Validate if the designated constraints aren't met.
type SignTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignTransactionResponseValidationError) ErrorName() string {
	return "SignTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SignTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignTransactionResponseValidationError{}

// Validate checks the field values on SubmitTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *SubmitTransactionRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetTransaction() == nil {
		return SubmitTransactionRequestValidationError{
			field:  "Transaction",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitTransactionRequestValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetInvoiceList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitTransactionRequestValidationError{
				field:  "InvoiceList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Commitment

	if len(m.GetDedupeId()) > 64 {
		return SubmitTransactionRequestValidationError{
			field:  "DedupeId",
			reason: "value length must be at most 64 bytes",
		}
	}

	// no validation rules for SendSimulationEvent

	return nil
}

// SubmitTransactionRequestValidationError is the validation error returned by
// SubmitTransactionRequest.Validate if the designated constraints aren't met.
type SubmitTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitTransactionRequestValidationError) ErrorName() string {
	return "SubmitTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitTransactionRequestValidationError{}

// Validate checks the field values on SubmitTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *SubmitTransactionResponse) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Result

	if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitTransactionResponseValidationError{
				field:  "Signature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetTransactionError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmitTransactionResponseValidationError{
				field:  "TransactionError",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInvoiceErrors() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmitTransactionResponseValidationError{
					field:  fmt.Sprintf("InvoiceErrors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// SubmitTransactionResponseValidationError is the validation error returned by
// SubmitTransactionResponse.Validate if the designated constraints aren't met.
type SubmitTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitTransactionResponseValidationError) ErrorName() string {
	return "SubmitTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitTransactionResponseValidationError{}

// Validate checks the field values on GetTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetTransactionRequest) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetTransactionId() == nil {
		return GetTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetTransactionId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransactionRequestValidationError{
				field:  "TransactionId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Commitment

	return nil
}

// GetTransactionRequestValidationError is the validation error returned by
// GetTransactionRequest.Validate if the designated constraints aren't met.
type GetTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionRequestValidationError) ErrorName() string {
	return "GetTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionRequestValidationError{}

// Validate checks the field values on GetTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetTransactionResponse) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for State

	// no validation rules for Slot

	// no validation rules for Confirmations

	if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransactionResponseValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// GetTransactionResponseValidationError is the validation error returned by
// GetTransactionResponse.Validate if the designated constraints aren't met.
type GetTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionResponseValidationError) ErrorName() string {
	return "GetTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionResponseValidationError{}

// Validate checks the field values on HistoryItem with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *HistoryItem) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetTransactionId() == nil {
		return HistoryItemValidationError{
			field:  "TransactionId",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetTransactionId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoryItemValidationError{
				field:  "TransactionId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoryItemValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetTransactionError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoryItemValidationError{
				field:  "TransactionError",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPayments() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HistoryItemValidationError{
					field:  fmt.Sprintf("Payments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if v, ok := interface{}(m.GetInvoiceList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoryItemValidationError{
				field:  "InvoiceList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetTransactionTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoryItemValidationError{
				field:  "TransactionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.RawTransaction.(type) {

	case *HistoryItem_SolanaTransaction:

		if v, ok := interface{}(m.GetSolanaTransaction()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HistoryItemValidationError{
					field:  "SolanaTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *HistoryItem_StellarTransaction:

		if v, ok := interface{}(m.GetStellarTransaction()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HistoryItemValidationError{
					field:  "StellarTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// HistoryItemValidationError is the validation error returned by
// HistoryItem.Validate if the designated constraints aren't met.
type HistoryItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistoryItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistoryItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistoryItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistoryItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistoryItemValidationError) ErrorName() string { return "HistoryItemValidationError" }

// Error satisfies the builtin error interface
func (e HistoryItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistoryItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistoryItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistoryItemValidationError{}

// Validate checks the field values on Cursor with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Cursor) Validate() error {
	if m == nil {
		return nil
	}

	if l := len(m.GetValue()); l < 1 || l > 128 {
		return CursorValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 128 bytes, inclusive",
		}
	}

	return nil
}

// CursorValidationError is the validation error returned by Cursor.Validate if
// the designated constraints aren't met.
type CursorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CursorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CursorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CursorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CursorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CursorValidationError) ErrorName() string { return "CursorValidationError" }

// Error satisfies the builtin error interface
func (e CursorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCursor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CursorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CursorValidationError{}

// Validate checks the field values on HistoryItem_Payment with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *HistoryItem_Payment) Validate() error {
	if m == nil {
		return nil
	}

	if m.GetSource() == nil {
		return HistoryItem_PaymentValidationError{
			field:  "Source",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoryItem_PaymentValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetDestination() == nil {
		return HistoryItem_PaymentValidationError{
			field:  "Destination",
			reason: "value is required",
		}
	}

	if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoryItem_PaymentValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Amount

	// no validation rules for Index

	return nil
}

// HistoryItem_PaymentValidationError is the validation error returned by
// HistoryItem_Payment.Validate if the designated constraints aren't met.
type HistoryItem_PaymentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistoryItem_PaymentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistoryItem_PaymentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistoryItem_PaymentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistoryItem_PaymentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistoryItem_PaymentValidationError) ErrorName() string {
	return "HistoryItem_PaymentValidationError"
}

// Error satisfies the builtin error interface
func (e HistoryItem_PaymentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistoryItem_Payment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistoryItem_PaymentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistoryItem_PaymentValidationError{}
